# Rust Workspace Setup Research

## 1. Workspace Cargo.toml Structure and Configuration

### Decision: Use Virtual Workspace with Resolver Version 3

**Configuration:**
```toml
[workspace]
resolver = "3"
members = [
    "crush-core",
    "crush-cli",
]

[workspace.dependencies]
# Shared dependencies across workspace members
rayon = "1.10"
flate2 = "1.0"
crc32fast = "1.4"
memmap2 = "0.9"
thiserror = "2.0"

# Dev dependencies (benchmarks and testing)
criterion = { version = "0.5", features = ["html_reports"] }

# CLI-specific
clap = { version = "4.5", features = ["derive"] }

[workspace.metadata]
# Workspace-level metadata
authors = ["Crush Contributors"]
edition = "2026"
rust-version = "1.84"
license = "MIT OR Apache-2.0"

[profile.release]
# Shared release profile for all members
lto = true
codegen-units = 1
strip = true
opt-level = 3

[profile.bench]
inherits = "release"
```

### Rationale

1. **Virtual Workspace**: No root package allows clean separation between library and binary concerns. The workspace Cargo.toml serves purely as a coordinator without competing with member crates.

2. **Resolver Version 3**: Latest resolver (Rust 1.84+, Edition 2024) provides Rust-version aware dependency resolution. When set to `resolver.incompatible-rust-version = "fallback"`, it automatically selects compatible dependency versions based on the project's MSRV (Minimum Supported Rust Version).

3. **Workspace Dependencies Table**: Centralizes version management in `[workspace.dependencies]`, ensuring all members use identical dependency versions. This prevents version conflicts and simplifies maintenance. Members inherit these using `dependency = { workspace = true }` syntax.

4. **Shared Profiles**: `[profile.*]` sections are only recognized in the root manifest. Defining release and benchmark profiles here ensures consistent optimization across the entire workspace.

5. **Unified Cargo.lock**: Workspace maintains a single lockfile at the root, guaranteeing dependency version consistency across all crates and preventing integration issues between members.

### Alternatives Considered

- **Root Package Workspace**: Adding `[package]` to the root Cargo.toml creates ambiguity about the workspace's primary purpose. Virtual workspaces provide clearer intent.

- **Resolver Version 2**: While stable and widely used, resolver v2 lacks Rust-version aware resolution. Version 3 is the future-proof choice for Edition 2024 projects.

- **Per-Crate Dependency Versions**: Allows flexibility but creates maintenance burden and risk of version conflicts between workspace members. Workspace dependencies provide better consistency.

### References

- [Workspaces - The Cargo Book](https://doc.rust-lang.org/cargo/reference/workspaces.html)
- [Dependency Resolution - The Cargo Book](https://doc.rust-lang.org/cargo/reference/resolver.html)
- [Cargo: Rust-version aware resolver - The Rust Edition Guide](https://doc.rust-lang.org/edition-guide/rust-2024/cargo-resolver.html)

---

## 2. .gitignore Best Practices for Rust Projects

### Decision: Use Official Rust Template with Cargo.lock Inclusion

**Configuration (.gitignore):**
```gitignore
# Compiled files and executables
/target/
**/*.rs.bk
*.pdb

# Mutation testing output
**/mutants.out*/

# IDE-specific files (optional - can use global gitignore)
.vscode/
.idea/
*.swp
*.swo

# OS-specific files
.DS_Store
Thumbs.db

# Environment files
.env
.env.local

# Documentation build artifacts (keep source .md files)
/book/

# Backup files
*~
```

**Important: DO NOT ignore Cargo.lock for executables/applications**

### Rationale

1. **Target Directory**: The `/target/` directory contains all build artifacts, intermediate compilation files, and executables. This can grow to hundreds of megabytes and should never be committed.

2. **Rustfmt Backups**: `**/*.rs.bk` files are backup files created by rustfmt during code formatting. These are temporary and should be excluded.

3. **MSVC Debug Symbols**: `*.pdb` files are debugging information files generated by MSVC on Windows builds. Not needed in version control.

4. **Mutation Testing**: `**/mutants.out*/` directories are created by mutation testing tools like `cargo-mutants`. These contain generated test variants and should be excluded.

5. **Cargo.lock Handling**:
   - **For applications/binaries**: INCLUDE Cargo.lock (track exact dependency versions for reproducible builds)
   - **For libraries only**: EXCLUDE Cargo.lock (let downstream users resolve their own dependencies)
   - Since Crush is both a library and a CLI application, we INCLUDE Cargo.lock

6. **IDE Files**: Can be excluded per-project or via global gitignore (`~/.gitignore_global`). Project-level exclusion ensures consistency across team members.

### Alternatives Considered

- **Ignoring Cargo.lock**: Appropriate only for pure library crates. Since we have a CLI binary (`crush-cli`), we need reproducible builds with exact dependency versions.

- **Committing /target/**: Would bloat repository size massively (100+ MB) and cause merge conflicts. Build artifacts should be generated locally.

- **Global gitignore only**: Works for individual developers but doesn't ensure team-wide consistency. Project-level .gitignore provides explicit contract.

### References

- [gitignore/Rust.gitignore - GitHub](https://github.com/github/gitignore/blob/main/Rust.gitignore)
- [Cargo.lock in the Cargo Book](https://doc.rust-lang.org/cargo/guide/cargo-toml-vs-cargo-lock.html)

---

## 3. rust-toolchain.toml Configuration

### Decision: Pin to Stable Channel with Minimal Profile

**Configuration (rust-toolchain.toml):**
```toml
[toolchain]
channel = "1.84.0"
components = ["rustfmt", "clippy", "rust-analyzer"]
profile = "minimal"
```

### Rationale

1. **Pinned Channel**: Specifying exact version `1.84.0` ensures reproducible builds across all development environments and CI/CD pipelines. All team members and build servers use identical compiler version.

2. **Minimal Profile**: Reduces installation size and setup time. The minimal profile includes only the compiler, cargo, and rust-std. Additional tools are explicitly added via components.

3. **Essential Components**:
   - `rustfmt`: Automatic code formatting (required for consistent style)
   - `clippy`: Linting tool (required for code quality enforcement)
   - `rust-analyzer`: LSP implementation (enables IDE features like autocomplete, go-to-definition)

4. **Automatic Toolchain Installation**: When developers run any cargo command, rustup automatically installs the specified toolchain if not present. No manual setup required.

5. **rust-analyzer Integration**: Including rust-analyzer in the toolchain file ensures the LSP uses the project's pinned Rust version, preventing version mismatch issues.

### Alternatives Considered

- **Floating "stable" Channel**: Using `channel = "stable"` would allow automatic updates to latest stable Rust. Rejected because it can cause unexpected breakages and inconsistent behavior across team members who update at different times.

- **Nightly Channel**: Required only for experimental features or unstable APIs. Crush targets stable Rust, so nightly is unnecessary and would introduce instability.

- **Default Profile**: Includes additional components like rust-docs and cargo-doc. Unnecessary bloat for CI environments. Minimal + explicit components provides better control.

- **No rust-toolchain.toml**: Relies on system-installed Rust version. Rejected because it creates inconsistencies between developers and makes onboarding harder.

### Update Strategy

- **Patch Updates**: Safe to update patch versions (1.84.0 → 1.84.1) for bugfixes
- **Minor Updates**: Quarterly review of new stable releases (1.84 → 1.85)
- **Testing**: Run full test suite before updating channel version
- **Documentation**: Document toolchain update in CHANGELOG

### References

- [Overrides - The rustup book](https://rust-lang.github.io/rustup/overrides.html)
- [Toolchains - The rustup book](https://rust-lang.github.io/rustup/concepts/toolchains.html)

---

## 4. rustfmt.toml and clippy.toml Configuration

### Decision: Strict Formatting with Pedantic Clippy Lints

**Configuration (rustfmt.toml):**
```toml
# Edition must match Cargo.toml
edition = "2024"

# Strict formatting rules
max_width = 100
hard_tabs = false
tab_spaces = 4

# Imports
imports_granularity = "Crate"
group_imports = "StdExternalCrate"

# Code organization
reorder_imports = true
reorder_modules = true

# Function formatting
fn_single_line = false
where_single_line = false

# Comments and documentation
wrap_comments = true
comment_width = 100
normalize_comments = true
normalize_doc_attributes = true

# Consistency
use_field_init_shorthand = true
use_try_shorthand = true
```

**Configuration (clippy.toml):**
```toml
# Cognitive complexity thresholds
cognitive-complexity-threshold = 15
too-many-arguments-threshold = 4
too-many-lines-threshold = 100

# Type complexity
type-complexity-threshold = 250

# Disallowed names (prevent placeholder variables in production)
disallowed-names = ["foo", "bar", "baz", "todo", "fixme"]

# Documentation requirements
missing-docs-in-crate-items = true

# Performance-critical project settings
avoid-breaking-exported-api = false
```

**In-code lint configuration (lib.rs/main.rs):**
```rust
// Deny all clippy warnings - treat as errors
#![deny(clippy::all)]
#![deny(clippy::pedantic)]
#![deny(clippy::perf)]
#![deny(clippy::correctness)]

// Additional strict lints
#![deny(clippy::unwrap_used)]
#![deny(clippy::expect_used)]
#![deny(clippy::panic)]
#![deny(clippy::missing_errors_doc)]
#![deny(clippy::missing_panics_doc)]
#![warn(clippy::missing_const_for_fn)]

// Shadow detection
#![warn(clippy::shadow_reuse)]
#![warn(clippy::shadow_same)]
#![warn(clippy::shadow_unrelated)]

// Character encoding
#![deny(non_ascii_idents)]

// Standard Rust lints
#![deny(unsafe_code)]
#![warn(missing_docs)]
#![warn(unused_qualifications)]
```

### Rationale

#### rustfmt Configuration

1. **Max Width 100**: Balances readability with modern widescreen displays. Industry standard for Rust projects (rustc itself uses 100).

2. **Import Organization**:
   - `imports_granularity = "Crate"` merges imports from the same crate
   - `group_imports = "StdExternalCrate"` separates std, external, and internal imports
   - Reduces diff noise and improves readability

3. **Comment Wrapping**: `wrap_comments = true` ensures documentation stays readable without horizontal scrolling. Critical for doc comments that become rustdoc output.

4. **Shorthand Syntax**: `use_field_init_shorthand` and `use_try_shorthand` enforce modern Rust idioms (e.g., `?` operator instead of `try!` macro).

#### clippy Configuration

1. **Cognitive Complexity Limit (15)**: Functions exceeding this threshold are hard to test and maintain. Enforces SOLID principles and encourages refactoring.

2. **Argument Limit (4)**: More than 4 arguments suggests need for a struct or builder pattern. Improves API ergonomics.

3. **Lines per Function (100)**: Large functions indicate SRP violations. Encourages decomposition into smaller, testable units.

4. **Disallowed Names**: Prevents placeholder variables (`foo`, `bar`) from reaching production. Enforces meaningful variable names.

5. **Missing Docs Requirement**: Aligns with Crush constitution requirement for comprehensive documentation.

#### In-Code Lints

1. **Deny unwrap/expect/panic**: Enforces Crush constitution principle "No `.unwrap()` in production". Forces explicit error handling.

2. **Pedantic Group**: Catches subtle bugs and non-idiomatic code. May have false positives but improves overall code quality.

3. **Performance Group**: Critical for Crush's "Performance First" principle. Flags inefficient patterns like unnecessary clones.

4. **Documentation Lints**: `missing_errors_doc` and `missing_panics_doc` ensure API contracts are explicit about failure modes.

5. **Unsafe Code Denial**: Enforces "100% memory safe Rust" principle from constitution. Any unsafe code requires explicit #[allow] with justification comment.

### CI/CD Integration

Run lints in CI with zero-tolerance for warnings:
```bash
cargo fmt -- --check              # Fail if unformatted
cargo clippy --all-targets -- -D warnings  # Treat warnings as errors
```

### Alternatives Considered

- **Warn Instead of Deny**: More permissive but allows technical debt accumulation. Deny + allow(explicit) is better for high-quality codebases.

- **Default Clippy Lints Only**: Misses many valuable checks in pedantic and perf groups. Too lenient for performance-critical system.

- **No rustfmt.toml**: Uses Rust defaults which may not match team preferences. Explicit configuration provides consistency.

- **Higher Complexity Thresholds**: Would allow more complex functions but reduces maintainability. Lower thresholds force better architecture.

### References

- [Configuration - Clippy Documentation](https://doc.rust-lang.org/clippy/configuration.html)
- [Clippy Lints](https://rust-lang.github.io/rust-clippy/master/index.html)
- [Pedantic Clippy - Yury Zhauniarovich](https://zhauniarovich.com/post/2021/2021-09-pedantic-clippy/)
- [rustfmt Configuration](https://rust-lang.github.io/rustfmt/)

---

## 5. Minimal Project Structure for Library + Binary Crates

### Decision: Flat Workspace with Core Library and Thin CLI Wrapper

**Structure:**
```
crush/
├── Cargo.toml              # Virtual workspace manifest
├── Cargo.lock              # Unified dependency lockfile
├── rust-toolchain.toml     # Toolchain specification
├── rustfmt.toml            # Formatting rules
├── clippy.toml             # Linting configuration
├── .gitignore              # VCS exclusions
│
├── crush-core/             # Library crate
│   ├── Cargo.toml          # Library manifest
│   ├── src/
│   │   ├── lib.rs          # Crate root with module declarations
│   │   ├── engine.rs       # Core compression engine
│   │   ├── stream.rs       # Streaming I/O abstractions
│   │   ├── block.rs        # Block processing
│   │   └── error.rs        # Error types using thiserror
│   ├── tests/              # Integration tests
│   │   └── compression_tests.rs
│   └── benches/            # Criterion benchmarks
│       └── compression_bench.rs
│
├── crush-cli/              # Binary crate
│   ├── Cargo.toml          # Binary manifest with crush-core dependency
│   └── src/
│       ├── main.rs         # Entry point
│       ├── args.rs         # CLI argument parsing (clap)
│       └── signal.rs       # Signal handling (Ctrl+C)
│
├── tests/                  # Workspace-level integration tests (optional)
│   └── end_to_end.rs
│
└── docs/                   # Additional documentation
    └── architecture.md
```

**crush-core/Cargo.toml:**
```toml
[package]
name = "crush-core"
version = "0.1.0"
edition.workspace = true
authors.workspace = true
license.workspace = true
rust-version.workspace = true

[dependencies]
rayon = { workspace = true }
flate2 = { workspace = true }
crc32fast = { workspace = true }
memmap2 = { workspace = true }
thiserror = { workspace = true }

[dev-dependencies]
criterion = { workspace = true }

[[bench]]
name = "compression_bench"
harness = false
```

**crush-cli/Cargo.toml:**
```toml
[package]
name = "crush"
version = "0.1.0"
edition.workspace = true
authors.workspace = true
license.workspace = true
rust-version.workspace = true

[dependencies]
crush-core = { path = "../crush-core" }
clap = { workspace = true }

[[bin]]
name = "crush"
path = "src/main.rs"
```

### Rationale

1. **Flat Structure**: All crates live at the workspace root level. Avoids deeply nested paths and makes navigation easier. Alternative `crates/` subdirectory is unnecessary for small workspaces (2-3 crates).

2. **Naming Convention**:
   - Library: `crush-core` (descriptive, distinguishes from CLI)
   - Binary: `crush` (user-facing name without suffix)
   - Crate names use hyphens, module names use underscores (Rust convention)

3. **Separation of Concerns**:
   - `crush-core`: Pure library with no I/O dependencies, reusable as a dependency
   - `crush-cli`: Thin wrapper handling CLI parsing, signals, and I/O
   - Enables future Python bindings, WASM targets, or GUI without modifying core

4. **Test Organization**:
   - Unit tests: Inline with modules using `#[cfg(test)]` (tests private APIs)
   - Integration tests: `crush-core/tests/` (tests public API only)
   - End-to-end tests: Workspace-level `tests/` (tests CLI behavior)

5. **Benchmarks**: Per-crate `benches/` directories with `harness = false` for Criterion. Workspace-level benchmarks possible but less common.

6. **Workspace Metadata Inheritance**: Using `edition.workspace = true` syntax reduces duplication and ensures consistency across all crates.

### File Responsibilities

**lib.rs:**
- Crate-level documentation (module overview, examples)
- Re-exports of public API
- Module declarations
- Crate-level lint configuration

**main.rs:**
- Argument parsing setup
- Error handling and user-facing error messages
- Signal handling (graceful shutdown)
- Thin wrapper around library functions

### Alternatives Considered

- **Single Crate with Binary**: Simpler initially but couples library to CLI concerns. Limits reusability and makes testing harder.

- **Crates Subdirectory**: Common in large workspaces (10+ crates) but unnecessary overhead for 2-3 crates. Adds extra nesting without benefit.

- **Monorepo with Multiple Libraries**: Over-engineering for current scope. Start simple, refactor later if needed (YAGNI principle).

- **Nested Module Hierarchies**: Deep module trees (`lib.rs` → `compression/mod.rs` → `gzip/mod.rs`) create navigation overhead. Prefer flat module structure in lib.rs with files at `src/*.rs`.

### References

- [Cargo Workspaces - The Rust Programming Language](https://doc.rust-lang.org/book/ch14-03-cargo-workspaces.html)
- [Packages, Crates, and Modules](https://doc.rust-lang.org/book/ch07-00-managing-growing-projects-with-packages-crates-and-modules.html)

---

## 6. Documentation Standards

### Decision: Comprehensive Doc Comments with Separate README

**Documentation Strategy:**

1. **Crate-Level Documentation (lib.rs):**
```rust
//! # Crush Core
//!
//! High-performance parallel compression library with pluggable algorithms.
//!
//! ## Quick Start
//!
//! ```rust
//! use crush_core::{Compressor, CompressionLevel};
//!
//! # fn main() -> Result<(), Box<dyn std::error::Error>> {
//! let data = b"Hello, world!";
//! let compressor = Compressor::new(CompressionLevel::Default);
//! let compressed = compressor.compress(data)?;
//! # Ok(())
//! # }
//! ```
//!
//! ## Features
//!
//! - **Parallel Processing**: Multi-threaded compression using Rayon
//! - **Memory Efficient**: Streaming API with configurable buffer sizes
//! - **Plugin System**: Support for multiple compression algorithms
//!
//! ## Architecture
//!
//! See [`Compressor`] for the main entry point and [`stream`] module for
//! streaming operations.
```

2. **Module-Level Documentation:**
```rust
//! Stream processing utilities for chunk-based compression.
//!
//! This module provides [`StreamCompressor`] for processing large files
//! without loading them entirely into memory.
```

3. **Item Documentation (Functions, Structs, Traits):**
```rust
/// Compresses data using the specified algorithm and level.
///
/// # Arguments
///
/// * `input` - Raw data to compress
/// * `level` - Compression level (1-9, where 9 is maximum compression)
///
/// # Returns
///
/// Compressed data as a `Vec<u8>`.
///
/// # Errors
///
/// Returns [`CompressionError::InvalidInput`] if input is empty.
/// Returns [`CompressionError::IoError`] if underlying I/O fails.
///
/// # Examples
///
/// ```rust
/// use crush_core::compress;
///
/// # fn main() -> Result<(), Box<dyn std::error::Error>> {
/// let data = b"test data";
/// let compressed = compress(data, 6)?;
/// assert!(compressed.len() < data.len());
/// # Ok(())
/// # }
/// ```
///
/// # Panics
///
/// Never panics under normal operation (all errors returned as `Result`).
pub fn compress(input: &[u8], level: u8) -> Result<Vec<u8>, CompressionError> {
    // Implementation
}
```

4. **README.md Structure:**
```markdown
# Crush

High-performance parallel compression CLI and library.

## Installation

### From Source
```bash
cargo install --path crush-cli
```

### As Library
```toml
[dependencies]
crush-core = "0.1"
```

## Usage

### CLI
```bash
crush compress input.txt -o output.crush
crush decompress output.crush -o restored.txt
```

### Library
```rust
use crush_core::{Compressor, CompressionLevel};

let compressor = Compressor::new(CompressionLevel::Default);
let compressed = compressor.compress(b"data")?;
```

## Performance

Benchmarks on Intel i7-9700K (8 cores):
- Single-threaded: 450 MB/s
- Multi-threaded: 2.1 GB/s

## License

MIT OR Apache-2.0
```

### Rationale

1. **Separate README and Crate Docs**:
   - README: Marketing, installation, quick examples (for GitHub/crates.io viewers)
   - Crate docs: Comprehensive API reference, architecture (for library users)
   - **Do NOT** use `#![doc = include_str!("../README.md")]` - forces same content to serve two purposes, worse at both

2. **Documentation Sections**:
   - **Summary**: One-sentence description (shows in search results)
   - **Examples**: Runnable code (compiled as doc-tests)
   - **Errors**: Explicit error conditions (part of API contract)
   - **Panics**: When function can panic (required by Clippy)

3. **Doc-Tests as Examples**: All code in doc comments is compiled and run by `cargo test`. Ensures examples stay up-to-date with code changes. Use `# fn main()` and `# Ok(())` for hidden setup boilerplate.

4. **Cross-References**: Use `[`Type`]` or `[`module`]` for automatic linking to other docs. Improves navigation in generated rustdoc.

5. **Mandatory Documentation**: Enabled via `#![warn(missing_docs)]` and `clippy::missing_docs_in_crate_items`. Every public item requires docs.

### Documentation Checklist for Public Items

- [ ] One-line summary (first paragraph)
- [ ] Detailed explanation (second paragraph)
- [ ] At least one runnable example
- [ ] Error documentation (if returns `Result`)
- [ ] Panic documentation (if can panic)
- [ ] Link to related items

### Building and Viewing Docs

```bash
# Build documentation
cargo doc --no-deps --open

# Build with private items (development)
cargo doc --no-deps --document-private-items

# Check for broken links
cargo doc --no-deps 2>&1 | grep warning
```

### Alternatives Considered

- **README.md as Crate Docs**: Common pattern but creates compromise between marketing content and API reference. Separate files serve distinct audiences better.

- **Minimal Documentation**: Faster to write but creates maintenance burden and reduces adoption. Well-documented code is easier to maintain and attracts contributors.

- **External Documentation Site**: Tools like mdBook provide rich documentation but add complexity. Start with rustdoc, migrate later if needed.

### References

- [How to Write Documentation - The rustdoc book](https://doc.rust-lang.org/rustdoc/how-to-write-documentation.html)
- [Documentation - Rust API Guidelines](https://rust-lang.github.io/api-guidelines/documentation.html)
- [Making Great Docs with Rustdoc - Tangram Vision](https://www.tangramvision.com/blog/making-great-docs-with-rustdoc)

---

## 7. Testing Patterns in Rust Workspaces

### Decision: Three-Tier Testing Strategy (Unit, Integration, Doc)

**Testing Structure:**

```
crush-core/
├── src/
│   ├── lib.rs
│   ├── engine.rs          # Unit tests inline with #[cfg(test)]
│   └── stream.rs          # Unit tests inline
├── tests/                 # Integration tests
│   ├── compression_tests.rs
│   ├── stream_tests.rs
│   └── common/            # Shared test utilities
│       └── mod.rs
└── benches/
    └── criterion_bench.rs

crush-cli/
├── src/
│   └── main.rs            # Minimal logic, mostly integration tested
└── tests/
    └── cli_tests.rs       # Test CLI via Command::new()

tests/                     # Workspace-level integration tests
└── end_to_end.rs
```

**Example Unit Test (inline in src/engine.rs):**
```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_compress_empty_input() {
        let result = compress(&[], 6);
        assert!(result.is_err());
        assert!(matches!(result, Err(CompressionError::InvalidInput)));
    }

    #[test]
    fn test_roundtrip() {
        let original = b"Hello, world!";
        let compressed = compress(original, 6).unwrap();
        let decompressed = decompress(&compressed).unwrap();
        assert_eq!(original, &decompressed[..]);
    }
}
```

**Example Integration Test (tests/compression_tests.rs):**
```rust
use crush_core::{Compressor, CompressionLevel};

#[test]
fn test_public_api_compression() {
    let compressor = Compressor::new(CompressionLevel::Fast);
    let input = b"test data".repeat(1000);
    let compressed = compressor.compress(&input).unwrap();

    assert!(compressed.len() < input.len());
}

#[test]
fn test_error_handling() {
    let compressor = Compressor::new(CompressionLevel::Default);
    let result = compressor.compress(&[]);

    assert!(result.is_err());
}
```

**Shared Test Utilities (tests/common/mod.rs):**
```rust
use std::path::PathBuf;

pub fn test_data_path(filename: &str) -> PathBuf {
    PathBuf::from(env!("CARGO_MANIFEST_DIR"))
        .join("tests")
        .join("data")
        .join(filename)
}

pub fn generate_test_data(size: usize) -> Vec<u8> {
    (0..size).map(|i| (i % 256) as u8).collect()
}
```

**CLI Integration Test (crush-cli/tests/cli_tests.rs):**
```rust
use std::process::Command;
use assert_cmd::prelude::*;

#[test]
fn test_cli_compress_decompress() {
    let mut cmd = Command::cargo_bin("crush").unwrap();
    cmd.arg("compress")
       .arg("test.txt")
       .arg("-o")
       .arg("test.crush");

    cmd.assert().success();
}
```

**Doc Test Example (in lib.rs or module docs):**
```rust
/// Compresses data using DEFLATE algorithm.
///
/// # Examples
///
/// ```
/// use crush_core::compress;
///
/// let data = b"Hello, world!";
/// let compressed = compress(data, 6).unwrap();
/// assert!(compressed.len() > 0);
/// ```
pub fn compress(data: &[u8], level: u8) -> Result<Vec<u8>, CompressionError> {
    // Implementation
}
```

### Rationale

#### 1. Unit Tests (Inline with #[cfg(test)])

**Purpose**: Test individual functions and private implementation details.

**Benefits**:
- Direct access to private functions and modules
- Fast compilation (only compiled during `cargo test`)
- Co-located with implementation (easy to maintain)

**Best Practices**:
- Test edge cases (empty input, maximum values, boundary conditions)
- Test error paths explicitly
- Use `#[should_panic]` sparingly (prefer `Result` assertions)
- Mock external dependencies using traits

#### 2. Integration Tests (tests/ directory)

**Purpose**: Test public API as external consumers would use it.

**Benefits**:
- Validates crate's public interface
- Catches API usability issues
- Each file in `tests/` is a separate crate (can test multiple scenarios in isolation)

**Best Practices**:
- No access to private items (intentional - tests real usage)
- Use `common/` module for shared utilities (not auto-discovered as tests)
- Test cross-module interactions
- Validate error handling from user perspective

#### 3. Documentation Tests

**Purpose**: Ensure code examples in documentation remain valid.

**Benefits**:
- Examples are guaranteed to compile and run
- Forces documentation to include runnable code
- Serves as both documentation and regression tests

**Best Practices**:
- Use `# ` prefix to hide boilerplate (e.g., `# fn main()`, `# Ok(())`)
- Include error handling (`?` operator or `.unwrap()`)
- Keep examples focused (one concept per example)
- Use `no_run` attribute for expensive examples

### Workspace Testing Commands

```bash
# Run all tests in workspace
cargo test --workspace

# Run tests for specific crate
cargo test -p crush-core

# Run specific test
cargo test test_roundtrip

# Run with output visible
cargo test -- --nocapture

# Run integration tests only
cargo test --test compression_tests

# Run doc tests only
cargo test --doc

# Run tests with coverage (requires cargo-llvm-cov)
cargo llvm-cov --workspace --html
```

### TDD Workflow (Crush Constitution Requirement)

Per constitution: **Test-First Development mandatory**

1. **Write failing test** (Red):
```rust
#[test]
fn test_new_feature() {
    let result = new_feature();
    assert_eq!(result, expected_value);  // Fails - feature doesn't exist
}
```

2. **Implement minimal code** (Green):
```rust
pub fn new_feature() -> Type {
    expected_value  // Simplest implementation to pass test
}
```

3. **Refactor** (Refactor):
```rust
pub fn new_feature() -> Type {
    // Improved implementation
    // Maintain passing tests
}
```

### Test Coverage Requirements (Constitution)

- **Minimum**: 80% code coverage
- **Tools**: `cargo-llvm-cov` or `cargo-tarpaulin`
- **CI Integration**: Coverage reports uploaded to Codecov/Coveralls

### Property-Based Testing (Advanced)

For complex algorithms, use `proptest` or `quickcheck`:

```rust
use proptest::prelude::*;

proptest! {
    #[test]
    fn test_roundtrip_property(data: Vec<u8>) {
        let compressed = compress(&data, 6)?;
        let decompressed = decompress(&compressed)?;
        prop_assert_eq!(data, decompressed);
    }
}
```

### Alternatives Considered

- **Tests in src/ with test feature**: Complicates module structure and mixes test code with production code. Integration tests provide cleaner separation.

- **Single Integration Test File**: Harder to organize and run specific test suites. Multiple files provide better organization.

- **No Doc Tests**: Would allow documentation examples to drift from reality. Doc tests ensure examples remain valid.

- **External Test Harness**: Tools like `nextest` offer parallel execution and better output, but standard `cargo test` is sufficient initially. Migrate if needed.

### References

- [Test Organization - The Rust Programming Language](https://doc.rust-lang.org/book/ch11-03-test-organization.html)
- [Integration Testing in Rust](https://joshleeb.com/posts/rust-integration-tests.html)
- [cargo test - The Cargo Book](https://doc.rust-lang.org/cargo/commands/cargo-test.html)

---

## Summary Checklist

Minimal viable Rust workspace setup requires:

- [x] **Cargo.toml**: Virtual workspace, resolver 3, shared dependencies
- [x] **.gitignore**: Exclude /target/, include Cargo.lock (for binaries)
- [x] **rust-toolchain.toml**: Pin to stable (1.84.0), minimal profile + components
- [x] **rustfmt.toml**: Max width 100, import organization, comment wrapping
- [x] **clippy.toml**: Cognitive complexity limits, disallowed names
- [x] **Project Structure**: Flat workspace with crush-core (lib) + crush-cli (bin)
- [x] **Documentation**: Crate-level docs in lib.rs, separate README.md, doc-tests
- [x] **Testing**: Unit tests (inline), integration tests (tests/), doc tests

**Compilation Check:**
```bash
cargo build --workspace          # Must compile cleanly
cargo clippy --workspace -- -D warnings  # Must pass with zero warnings
cargo fmt --check                # Must be formatted
cargo test --workspace           # All tests must pass
cargo doc --no-deps              # Documentation must build
```

**Next Steps:**
1. Create workspace Cargo.toml with configuration above
2. Initialize crush-core and crush-cli crates
3. Set up toolchain, formatting, and linting configs
4. Implement minimal lib.rs and main.rs stubs
5. Verify clean compilation with strict lints

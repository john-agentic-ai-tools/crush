# Rust Workspace Setup Research

## 1. Workspace Cargo.toml Structure and Configuration

### Decision: Use Virtual Workspace with Resolver Version 3

**Configuration:**
```toml
[workspace]
resolver = "3"
members = [
    "crush-core",
    "crush-cli",
]

[workspace.dependencies]
# Shared dependencies across workspace members
rayon = "1.10"
flate2 = "1.0"
crc32fast = "1.4"
memmap2 = "0.9"
thiserror = "2.0"

# Dev dependencies (benchmarks and testing)
criterion = { version = "0.5", features = ["html_reports"] }

# CLI-specific
clap = { version = "4.5", features = ["derive"] }

[workspace.metadata]
# Workspace-level metadata
authors = ["Crush Contributors"]
edition = "2026"
rust-version = "1.84"
license = "MIT OR Apache-2.0"

[profile.release]
# Shared release profile for all members
lto = true
codegen-units = 1
strip = true
opt-level = 3

[profile.bench]
inherits = "release"
```

### Rationale

1. **Virtual Workspace**: No root package allows clean separation between library and binary concerns. The workspace Cargo.toml serves purely as a coordinator without competing with member crates.

2. **Resolver Version 3**: Latest resolver (Rust 1.84+, Edition 2024) provides Rust-version aware dependency resolution. When set to `resolver.incompatible-rust-version = "fallback"`, it automatically selects compatible dependency versions based on the project's MSRV (Minimum Supported Rust Version).

3. **Workspace Dependencies Table**: Centralizes version management in `[workspace.dependencies]`, ensuring all members use identical dependency versions. This prevents version conflicts and simplifies maintenance. Members inherit these using `dependency = { workspace = true }` syntax.

4. **Shared Profiles**: `[profile.*]` sections are only recognized in the root manifest. Defining release and benchmark profiles here ensures consistent optimization across the entire workspace.

5. **Unified Cargo.lock**: Workspace maintains a single lockfile at the root, guaranteeing dependency version consistency across all crates and preventing integration issues between members.

### Alternatives Considered

- **Root Package Workspace**: Adding `[package]` to the root Cargo.toml creates ambiguity about the workspace's primary purpose. Virtual workspaces provide clearer intent.

- **Resolver Version 2**: While stable and widely used, resolver v2 lacks Rust-version aware resolution. Version 3 is the future-proof choice for Edition 2024 projects.

- **Per-Crate Dependency Versions**: Allows flexibility but creates maintenance burden and risk of version conflicts between workspace members. Workspace dependencies provide better consistency.

### References

- [Workspaces - The Cargo Book](https://doc.rust-lang.org/cargo/reference/workspaces.html)
- [Dependency Resolution - The Cargo Book](https://doc.rust-lang.org/cargo/reference/resolver.html)
- [Cargo: Rust-version aware resolver - The Rust Edition Guide](https://doc.rust-lang.org/edition-guide/rust-2024/cargo-resolver.html)

---

## 2. .gitignore Best Practices for Rust Projects

### Decision: Use Official Rust Template with Cargo.lock Inclusion

**Configuration (.gitignore):**
```gitignore
# Compiled files and executables
/target/
**/*.rs.bk
*.pdb

# Mutation testing output
**/mutants.out*/

# IDE-specific files (optional - can use global gitignore)
.vscode/
.idea/
*.swp
*.swo

# OS-specific files
.DS_Store
Thumbs.db

# Environment files
.env
.env.local

# Documentation build artifacts (keep source .md files)
/book/

# Backup files
*~
```

**Important: DO NOT ignore Cargo.lock for executables/applications**

### Rationale

1. **Target Directory**: The `/target/` directory contains all build artifacts, intermediate compilation files, and executables. This can grow to hundreds of megabytes and should never be committed.

2. **Rustfmt Backups**: `**/*.rs.bk` files are backup files created by rustfmt during code formatting. These are temporary and should be excluded.

3. **MSVC Debug Symbols**: `*.pdb` files are debugging information files generated by MSVC on Windows builds. Not needed in version control.

4. **Mutation Testing**: `**/mutants.out*/` directories are created by mutation testing tools like `cargo-mutants`. These contain generated test variants and should be excluded.

5. **Cargo.lock Handling**:
   - **For applications/binaries**: INCLUDE Cargo.lock (track exact dependency versions for reproducible builds)
   - **For libraries only**: EXCLUDE Cargo.lock (let downstream users resolve their own dependencies)
   - Since Crush is both a library and a CLI application, we INCLUDE Cargo.lock

6. **IDE Files**: Can be excluded per-project or via global gitignore (`~/.gitignore_global`). Project-level exclusion ensures consistency across team members.

### Alternatives Considered

- **Ignoring Cargo.lock**: Appropriate only for pure library crates. Since we have a CLI binary (`crush-cli`), we need reproducible builds with exact dependency versions.

- **Committing /target/**: Would bloat repository size massively (100+ MB) and cause merge conflicts. Build artifacts should be generated locally.

- **Global gitignore only**: Works for individual developers but doesn't ensure team-wide consistency. Project-level .gitignore provides explicit contract.

### References

- [gitignore/Rust.gitignore - GitHub](https://github.com/github/gitignore/blob/main/Rust.gitignore)
- [Cargo.lock in the Cargo Book](https://doc.rust-lang.org/cargo/guide/cargo-toml-vs-cargo-lock.html)

---

## 3. rust-toolchain.toml Configuration

### Decision: Pin to Stable Channel with Minimal Profile

**Configuration (rust-toolchain.toml):**
```toml
[toolchain]
channel = "1.84.0"
components = ["rustfmt", "clippy", "rust-analyzer"]
profile = "minimal"
```

### Rationale

1. **Pinned Channel**: Specifying exact version `1.84.0` ensures reproducible builds across all development environments and CI/CD pipelines. All team members and build servers use identical compiler version.

2. **Minimal Profile**: Reduces installation size and setup time. The minimal profile includes only the compiler, cargo, and rust-std. Additional tools are explicitly added via components.

3. **Essential Components**:
   - `rustfmt`: Automatic code formatting (required for consistent style)
   - `clippy`: Linting tool (required for code quality enforcement)
   - `rust-analyzer`: LSP implementation (enables IDE features like autocomplete, go-to-definition)

4. **Automatic Toolchain Installation**: When developers run any cargo command, rustup automatically installs the specified toolchain if not present. No manual setup required.

5. **rust-analyzer Integration**: Including rust-analyzer in the toolchain file ensures the LSP uses the project's pinned Rust version, preventing version mismatch issues.

### Alternatives Considered

- **Floating "stable" Channel**: Using `channel = "stable"` would allow automatic updates to latest stable Rust. Rejected because it can cause unexpected breakages and inconsistent behavior across team members who update at different times.

- **Nightly Channel**: Required only for experimental features or unstable APIs. Crush targets stable Rust, so nightly is unnecessary and would introduce instability.

- **Default Profile**: Includes additional components like rust-docs and cargo-doc. Unnecessary bloat for CI environments. Minimal + explicit components provides better control.

- **No rust-toolchain.toml**: Relies on system-installed Rust version. Rejected because it creates inconsistencies between developers and makes onboarding harder.

### Update Strategy

- **Patch Updates**: Safe to update patch versions (1.84.0 → 1.84.1) for bugfixes
- **Minor Updates**: Quarterly review of new stable releases (1.84 → 1.85)
- **Testing**: Run full test suite before updating channel version
- **Documentation**: Document toolchain update in CHANGELOG

### References

- [Overrides - The rustup book](https://rust-lang.github.io/rustup/overrides.html)
- [Toolchains - The rustup book](https://rust-lang.github.io/rustup/concepts/toolchains.html)

---

## 4. rustfmt.toml and clippy.toml Configuration

### Decision: Strict Formatting with Pedantic Clippy Lints

**Configuration (rustfmt.toml):**
```toml
# Edition must match Cargo.toml
edition = "2024"

# Strict formatting rules
max_width = 100
hard_tabs = false
tab_spaces = 4

# Imports
imports_granularity = "Crate"
group_imports = "StdExternalCrate"

# Code organization
reorder_imports = true
reorder_modules = true

# Function formatting
fn_single_line = false
where_single_line = false

# Comments and documentation
wrap_comments = true
comment_width = 100
normalize_comments = true
normalize_doc_attributes = true

# Consistency
use_field_init_shorthand = true
use_try_shorthand = true
```

**Configuration (clippy.toml):**
```toml
# Cognitive complexity thresholds
cognitive-complexity-threshold = 15
too-many-arguments-threshold = 4
too-many-lines-threshold = 100

# Type complexity
type-complexity-threshold = 250

# Disallowed names (prevent placeholder variables in production)
disallowed-names = ["foo", "bar", "baz", "todo", "fixme"]

# Documentation requirements
missing-docs-in-crate-items = true

# Performance-critical project settings
avoid-breaking-exported-api = false
```

**In-code lint configuration (lib.rs/main.rs):**
```rust
// Deny all clippy warnings - treat as errors
#![deny(clippy::all)]
#![deny(clippy::pedantic)]
#![deny(clippy::perf)]
#![deny(clippy::correctness)]

// Additional strict lints
#![deny(clippy::unwrap_used)]
#![deny(clippy::expect_used)]
#![deny(clippy::panic)]
#![deny(clippy::missing_errors_doc)]
#![deny(clippy::missing_panics_doc)]
#![warn(clippy::missing_const_for_fn)]

// Shadow detection
#![warn(clippy::shadow_reuse)]
#![warn(clippy::shadow_same)]
#![warn(clippy::shadow_unrelated)]

// Character encoding
#![deny(non_ascii_idents)]

// Standard Rust lints
#![deny(unsafe_code)]
#![warn(missing_docs)]
#![warn(unused_qualifications)]
```

### Rationale

#### rustfmt Configuration

1. **Max Width 100**: Balances readability with modern widescreen displays. Industry standard for Rust projects (rustc itself uses 100).

2. **Import Organization**:
   - `imports_granularity = "Crate"` merges imports from the same crate
   - `group_imports = "StdExternalCrate"` separates std, external, and internal imports
   - Reduces diff noise and improves readability

3. **Comment Wrapping**: `wrap_comments = true` ensures documentation stays readable without horizontal scrolling. Critical for doc comments that become rustdoc output.

4. **Shorthand Syntax**: `use_field_init_shorthand` and `use_try_shorthand` enforce modern Rust idioms (e.g., `?` operator instead of `try!` macro).

#### clippy Configuration

1. **Cognitive Complexity Limit (15)**: Functions exceeding this threshold are hard to test and maintain. Enforces SOLID principles and encourages refactoring.

2. **Argument Limit (4)**: More than 4 arguments suggests need for a struct or builder pattern. Improves API ergonomics.

3. **Lines per Function (100)**: Large functions indicate SRP violations. Encourages decomposition into smaller, testable units.

4. **Disallowed Names**: Prevents placeholder variables (`foo`, `bar`) from reaching production. Enforces meaningful variable names.

5. **Missing Docs Requirement**: Aligns with Crush constitution requirement for comprehensive documentation.

#### In-Code Lints

1. **Deny unwrap/expect/panic**: Enforces Crush constitution principle "No `.unwrap()` in production". Forces explicit error handling.

2. **Pedantic Group**: Catches subtle bugs and non-idiomatic code. May have false positives but improves overall code quality.

3. **Performance Group**: Critical for Crush's "Performance First" principle. Flags inefficient patterns like unnecessary clones.

4. **Documentation Lints**: `missing_errors_doc` and `missing_panics_doc` ensure API contracts are explicit about failure modes.

5. **Unsafe Code Denial**: Enforces "100% memory safe Rust" principle from constitution. Any unsafe code requires explicit #[allow] with justification comment.

### CI/CD Integration

Run lints in CI with zero-tolerance for warnings:
```bash
cargo fmt -- --check              # Fail if unformatted
cargo clippy --all-targets -- -D warnings  # Treat warnings as errors
```

### Alternatives Considered

- **Warn Instead of Deny**: More permissive but allows technical debt accumulation. Deny + allow(explicit) is better for high-quality codebases.

- **Default Clippy Lints Only**: Misses many valuable checks in pedantic and perf groups. Too lenient for performance-critical system.

- **No rustfmt.toml**: Uses Rust defaults which may not match team preferences. Explicit configuration provides consistency.

- **Higher Complexity Thresholds**: Would allow more complex functions but reduces maintainability. Lower thresholds force better architecture.

### References

- [Configuration - Clippy Documentation](https://doc.rust-lang.org/clippy/configuration.html)
- [Clippy Lints](https://rust-lang.github.io/rust-clippy/master/index.html)
- [Pedantic Clippy - Yury Zhauniarovich](https://zhauniarovich.com/post/2021/2021-09-pedantic-clippy/)
- [rustfmt Configuration](https://rust-lang.github.io/rustfmt/)

---

## 5. Minimal Project Structure for Library + Binary Crates

### Decision: Flat Workspace with Core Library and Thin CLI Wrapper

**Structure:**
```
crush/
├── Cargo.toml              # Virtual workspace manifest
├── Cargo.lock              # Unified dependency lockfile
├── rust-toolchain.toml     # Toolchain specification
├── rustfmt.toml            # Formatting rules
├── clippy.toml             # Linting configuration
├── .gitignore              # VCS exclusions
│
├── crush-core/             # Library crate
│   ├── Cargo.toml          # Library manifest
│   ├── src/
│   │   ├── lib.rs          # Crate root with module declarations
│   │   ├── engine.rs       # Core compression engine
│   │   ├── stream.rs       # Streaming I/O abstractions
│   │   ├── block.rs        # Block processing
│   │   └── error.rs        # Error types using thiserror
│   ├── tests/              # Integration tests
│   │   └── compression_tests.rs
│   └── benches/            # Criterion benchmarks
│       └── compression_bench.rs
│
├── crush-cli/              # Binary crate
│   ├── Cargo.toml          # Binary manifest with crush-core dependency
│   └── src/
│       ├── main.rs         # Entry point
│       ├── args.rs         # CLI argument parsing (clap)
│       └── signal.rs       # Signal handling (Ctrl+C)
│
├── tests/                  # Workspace-level integration tests (optional)
│   └── end_to_end.rs
│
└── docs/                   # Additional documentation
    └── architecture.md
```

**crush-core/Cargo.toml:**
```toml
[package]
name = "crush-core"
version = "0.1.0"
edition.workspace = true
authors.workspace = true
license.workspace = true
rust-version.workspace = true

[dependencies]
rayon = { workspace = true }
flate2 = { workspace = true }
crc32fast = { workspace = true }
memmap2 = { workspace = true }
thiserror = { workspace = true }

[dev-dependencies]
criterion = { workspace = true }

[[bench]]
name = "compression_bench"
harness = false
```

**crush-cli/Cargo.toml:**
```toml
[package]
name = "crush"
version = "0.1.0"
edition.workspace = true
authors.workspace = true
license.workspace = true
rust-version.workspace = true

[dependencies]
crush-core = { path = "../crush-core" }
clap = { workspace = true }

[[bin]]
name = "crush"
path = "src/main.rs"
```

### Rationale

1. **Flat Structure**: All crates live at the workspace root level. Avoids deeply nested paths and makes navigation easier. Alternative `crates/` subdirectory is unnecessary for small workspaces (2-3 crates).

2. **Naming Convention**:
   - Library: `crush-core` (descriptive, distinguishes from CLI)
   - Binary: `crush` (user-facing name without suffix)
   - Crate names use hyphens, module names use underscores (Rust convention)

3. **Separation of Concerns**:
   - `crush-core`: Pure library with no I/O dependencies, reusable as a dependency
   - `crush-cli`: Thin wrapper handling CLI parsing, signals, and I/O
   - Enables future Python bindings, WASM targets, or GUI without modifying core

4. **Test Organization**:
   - Unit tests: Inline with modules using `#[cfg(test)]` (tests private APIs)
   - Integration tests: `crush-core/tests/` (tests public API only)
   - End-to-end tests: Workspace-level `tests/` (tests CLI behavior)

5. **Benchmarks**: Per-crate `benches/` directories with `harness = false` for Criterion. Workspace-level benchmarks possible but less common.

6. **Workspace Metadata Inheritance**: Using `edition.workspace = true` syntax reduces duplication and ensures consistency across all crates.

### File Responsibilities

**lib.rs:**
- Crate-level documentation (module overview, examples)
- Re-exports of public API
- Module declarations
- Crate-level lint configuration

**main.rs:**
- Argument parsing setup
- Error handling and user-facing error messages
- Signal handling (graceful shutdown)
- Thin wrapper around library functions

### Alternatives Considered

- **Single Crate with Binary**: Simpler initially but couples library to CLI concerns. Limits reusability and makes testing harder.

- **Crates Subdirectory**: Common in large workspaces (10+ crates) but unnecessary overhead for 2-3 crates. Adds extra nesting without benefit.

- **Monorepo with Multiple Libraries**: Over-engineering for current scope. Start simple, refactor later if needed (YAGNI principle).

- **Nested Module Hierarchies**: Deep module trees (`lib.rs` → `compression/mod.rs` → `gzip/mod.rs`) create navigation overhead. Prefer flat module structure in lib.rs with files at `src/*.rs`.

### References

- [Cargo Workspaces - The Rust Programming Language](https://doc.rust-lang.org/book/ch14-03-cargo-workspaces.html)
- [Packages, Crates, and Modules](https://doc.rust-lang.org/book/ch07-00-managing-growing-projects-with-packages-crates-and-modules.html)

---

## 6. Documentation Standards

### Decision: Comprehensive Doc Comments with Separate README

**Documentation Strategy:**

1. **Crate-Level Documentation (lib.rs):**
```rust
//! # Crush Core
//!
//! High-performance parallel compression library with pluggable algorithms.
//!
//! ## Quick Start
//!
//! ```rust
//! use crush_core::{Compressor, CompressionLevel};
//!
//! # fn main() -> Result<(), Box<dyn std::error::Error>> {
//! let data = b"Hello, world!";
//! let compressor = Compressor::new(CompressionLevel::Default);
//! let compressed = compressor.compress(data)?;
//! # Ok(())
//! # }
//! ```
//!
//! ## Features
//!
//! - **Parallel Processing**: Multi-threaded compression using Rayon
//! - **Memory Efficient**: Streaming API with configurable buffer sizes
//! - **Plugin System**: Support for multiple compression algorithms
//!
//! ## Architecture
//!
//! See [`Compressor`] for the main entry point and [`stream`] module for
//! streaming operations.
```

2. **Module-Level Documentation:**
```rust
//! Stream processing utilities for chunk-based compression.
//!
//! This module provides [`StreamCompressor`] for processing large files
//! without loading them entirely into memory.
```

3. **Item Documentation (Functions, Structs, Traits):**
```rust
/// Compresses data using the specified algorithm and level.
///
/// # Arguments
///
/// * `input` - Raw data to compress
/// * `level` - Compression level (1-9, where 9 is maximum compression)
///
/// # Returns
///
/// Compressed data as a `Vec<u8>`.
///
/// # Errors
///
/// Returns [`CompressionError::InvalidInput`] if input is empty.
/// Returns [`CompressionError::IoError`] if underlying I/O fails.
///
/// # Examples
///
/// ```rust
/// use crush_core::compress;
///
/// # fn main() -> Result<(), Box<dyn std::error::Error>> {
/// let data = b"test data";
/// let compressed = compress(data, 6)?;
/// assert!(compressed.len() < data.len());
/// # Ok(())
/// # }
/// ```
///
/// # Panics
///
/// Never panics under normal operation (all errors returned as `Result`).
pub fn compress(input: &[u8], level: u8) -> Result<Vec<u8>, CompressionError> {
    // Implementation
}
```

4. **README.md Structure:**
```markdown
# Crush

High-performance parallel compression CLI and library.

## Installation

### From Source
```bash
cargo install --path crush-cli
```

### As Library
```toml
[dependencies]
crush-core = "0.1"
```

## Usage

### CLI
```bash
crush compress input.txt -o output.crush
crush decompress output.crush -o restored.txt
```

### Library
```rust
use crush_core::{Compressor, CompressionLevel};

let compressor = Compressor::new(CompressionLevel::Default);
let compressed = compressor.compress(b"data")?;
```

## Performance

Benchmarks on Intel i7-9700K (8 cores):
- Single-threaded: 450 MB/s
- Multi-threaded: 2.1 GB/s

## License

MIT OR Apache-2.0
```

### Rationale

1. **Separate README and Crate Docs**:
   - README: Marketing, installation, quick examples (for GitHub/crates.io viewers)
   - Crate docs: Comprehensive API reference, architecture (for library users)
   - **Do NOT** use `#![doc = include_str!("../README.md")]` - forces same content to serve two purposes, worse at both

2. **Documentation Sections**:
   - **Summary**: One-sentence description (shows in search results)
   - **Examples**: Runnable code (compiled as doc-tests)
   - **Errors**: Explicit error conditions (part of API contract)
   - **Panics**: When function can panic (required by Clippy)

3. **Doc-Tests as Examples**: All code in doc comments is compiled and run by `cargo test`. Ensures examples stay up-to-date with code changes. Use `# fn main()` and `# Ok(())` for hidden setup boilerplate.

4. **Cross-References**: Use `[`Type`]` or `[`module`]` for automatic linking to other docs. Improves navigation in generated rustdoc.

5. **Mandatory Documentation**: Enabled via `#![warn(missing_docs)]` and `clippy::missing_docs_in_crate_items`. Every public item requires docs.

### Documentation Checklist for Public Items

- [ ] One-line summary (first paragraph)
- [ ] Detailed explanation (second paragraph)
- [ ] At least one runnable example
- [ ] Error documentation (if returns `Result`)
- [ ] Panic documentation (if can panic)
- [ ] Link to related items

### Building and Viewing Docs

```bash
# Build documentation
cargo doc --no-deps --open

# Build with private items (development)
cargo doc --no-deps --document-private-items

# Check for broken links
cargo doc --no-deps 2>&1 | grep warning
```

### Alternatives Considered

- **README.md as Crate Docs**: Common pattern but creates compromise between marketing content and API reference. Separate files serve distinct audiences better.

- **Minimal Documentation**: Faster to write but creates maintenance burden and reduces adoption. Well-documented code is easier to maintain and attracts contributors.

- **External Documentation Site**: Tools like mdBook provide rich documentation but add complexity. Start with rustdoc, migrate later if needed.

### References

- [How to Write Documentation - The rustdoc book](https://doc.rust-lang.org/rustdoc/how-to-write-documentation.html)
- [Documentation - Rust API Guidelines](https://rust-lang.github.io/api-guidelines/documentation.html)
- [Making Great Docs with Rustdoc - Tangram Vision](https://www.tangramvision.com/blog/making-great-docs-with-rustdoc)

---

## 7. Testing Patterns in Rust Workspaces

### Decision: Three-Tier Testing Strategy (Unit, Integration, Doc)

**Testing Structure:**

```
crush-core/
├── src/
│   ├── lib.rs
│   ├── engine.rs          # Unit tests inline with #[cfg(test)]
│   └── stream.rs          # Unit tests inline
├── tests/                 # Integration tests
│   ├── compression_tests.rs
│   ├── stream_tests.rs
│   └── common/            # Shared test utilities
│       └── mod.rs
└── benches/
    └── criterion_bench.rs

crush-cli/
├── src/
│   └── main.rs            # Minimal logic, mostly integration tested
└── tests/
    └── cli_tests.rs       # Test CLI via Command::new()

tests/                     # Workspace-level integration tests
└── end_to_end.rs
```

**Example Unit Test (inline in src/engine.rs):**
```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_compress_empty_input() {
        let result = compress(&[], 6);
        assert!(result.is_err());
        assert!(matches!(result, Err(CompressionError::InvalidInput)));
    }

    #[test]
    fn test_roundtrip() {
        let original = b"Hello, world!";
        let compressed = compress(original, 6).unwrap();
        let decompressed = decompress(&compressed).unwrap();
        assert_eq!(original, &decompressed[..]);
    }
}
```

**Example Integration Test (tests/compression_tests.rs):**
```rust
use crush_core::{Compressor, CompressionLevel};

#[test]
fn test_public_api_compression() {
    let compressor = Compressor::new(CompressionLevel::Fast);
    let input = b"test data".repeat(1000);
    let compressed = compressor.compress(&input).unwrap();

    assert!(compressed.len() < input.len());
}

#[test]
fn test_error_handling() {
    let compressor = Compressor::new(CompressionLevel::Default);
    let result = compressor.compress(&[]);

    assert!(result.is_err());
}
```

**Shared Test Utilities (tests/common/mod.rs):**
```rust
use std::path::PathBuf;

pub fn test_data_path(filename: &str) -> PathBuf {
    PathBuf::from(env!("CARGO_MANIFEST_DIR"))
        .join("tests")
        .join("data")
        .join(filename)
}

pub fn generate_test_data(size: usize) -> Vec<u8> {
    (0..size).map(|i| (i % 256) as u8).collect()
}
```

**CLI Integration Test (crush-cli/tests/cli_tests.rs):**
```rust
use std::process::Command;
use assert_cmd::prelude::*;

#[test]
fn test_cli_compress_decompress() {
    let mut cmd = Command::cargo_bin("crush").unwrap();
    cmd.arg("compress")
       .arg("test.txt")
       .arg("-o")
       .arg("test.crush");

    cmd.assert().success();
}
```

**Doc Test Example (in lib.rs or module docs):**
```rust
/// Compresses data using DEFLATE algorithm.
///
/// # Examples
///
/// ```
/// use crush_core::compress;
///
/// let data = b"Hello, world!";
/// let compressed = compress(data, 6).unwrap();
/// assert!(compressed.len() > 0);
/// ```
pub fn compress(data: &[u8], level: u8) -> Result<Vec<u8>, CompressionError> {
    // Implementation
}
```

### Rationale

#### 1. Unit Tests (Inline with #[cfg(test)])

**Purpose**: Test individual functions and private implementation details.

**Benefits**:
- Direct access to private functions and modules
- Fast compilation (only compiled during `cargo test`)
- Co-located with implementation (easy to maintain)

**Best Practices**:
- Test edge cases (empty input, maximum values, boundary conditions)
- Test error paths explicitly
- Use `#[should_panic]` sparingly (prefer `Result` assertions)
- Mock external dependencies using traits

#### 2. Integration Tests (tests/ directory)

**Purpose**: Test public API as external consumers would use it.

**Benefits**:
- Validates crate's public interface
- Catches API usability issues
- Each file in `tests/` is a separate crate (can test multiple scenarios in isolation)

**Best Practices**:
- No access to private items (intentional - tests real usage)
- Use `common/` module for shared utilities (not auto-discovered as tests)
- Test cross-module interactions
- Validate error handling from user perspective

#### 3. Documentation Tests

**Purpose**: Ensure code examples in documentation remain valid.

**Benefits**:
- Examples are guaranteed to compile and run
- Forces documentation to include runnable code
- Serves as both documentation and regression tests

**Best Practices**:
- Use `# ` prefix to hide boilerplate (e.g., `# fn main()`, `# Ok(())`)
- Include error handling (`?` operator or `.unwrap()`)
- Keep examples focused (one concept per example)
- Use `no_run` attribute for expensive examples

### Workspace Testing Commands

```bash
# Run all tests in workspace
cargo test --workspace

# Run tests for specific crate
cargo test -p crush-core

# Run specific test
cargo test test_roundtrip

# Run with output visible
cargo test -- --nocapture

# Run integration tests only
cargo test --test compression_tests

# Run doc tests only
cargo test --doc

# Run tests with coverage (requires cargo-llvm-cov)
cargo llvm-cov --workspace --html
```

### TDD Workflow (Crush Constitution Requirement)

Per constitution: **Test-First Development mandatory**

1. **Write failing test** (Red):
```rust
#[test]
fn test_new_feature() {
    let result = new_feature();
    assert_eq!(result, expected_value);  // Fails - feature doesn't exist
}
```

2. **Implement minimal code** (Green):
```rust
pub fn new_feature() -> Type {
    expected_value  // Simplest implementation to pass test
}
```

3. **Refactor** (Refactor):
```rust
pub fn new_feature() -> Type {
    // Improved implementation
    // Maintain passing tests
}
```

### Test Coverage Requirements (Constitution)

- **Minimum**: 80% code coverage
- **Tools**: `cargo-llvm-cov` or `cargo-tarpaulin`
- **CI Integration**: Coverage reports uploaded to Codecov/Coveralls

### Property-Based Testing (Advanced)

For complex algorithms, use `proptest` or `quickcheck`:

```rust
use proptest::prelude::*;

proptest! {
    #[test]
    fn test_roundtrip_property(data: Vec<u8>) {
        let compressed = compress(&data, 6)?;
        let decompressed = decompress(&compressed)?;
        prop_assert_eq!(data, decompressed);
    }
}
```

### Alternatives Considered

- **Tests in src/ with test feature**: Complicates module structure and mixes test code with production code. Integration tests provide cleaner separation.

- **Single Integration Test File**: Harder to organize and run specific test suites. Multiple files provide better organization.

- **No Doc Tests**: Would allow documentation examples to drift from reality. Doc tests ensure examples remain valid.

- **External Test Harness**: Tools like `nextest` offer parallel execution and better output, but standard `cargo test` is sufficient initially. Migrate if needed.

### References

- [Test Organization - The Rust Programming Language](https://doc.rust-lang.org/book/ch11-03-test-organization.html)
- [Integration Testing in Rust](https://joshleeb.com/posts/rust-integration-tests.html)
- [cargo test - The Cargo Book](https://doc.rust-lang.org/cargo/commands/cargo-test.html)

---

## Summary Checklist

Minimal viable Rust workspace setup requires:

- [x] **Cargo.toml**: Virtual workspace, resolver 3, shared dependencies
- [x] **.gitignore**: Exclude /target/, include Cargo.lock (for binaries)
- [x] **rust-toolchain.toml**: Pin to stable (1.84.0), minimal profile + components
- [x] **rustfmt.toml**: Max width 100, import organization, comment wrapping
- [x] **clippy.toml**: Cognitive complexity limits, disallowed names
- [x] **Project Structure**: Flat workspace with crush-core (lib) + crush-cli (bin)
- [x] **Documentation**: Crate-level docs in lib.rs, separate README.md, doc-tests
- [x] **Testing**: Unit tests (inline), integration tests (tests/), doc tests

**Compilation Check:**
```bash
cargo build --workspace          # Must compile cleanly
cargo clippy --workspace -- -D warnings  # Must pass with zero warnings
cargo fmt --check                # Must be formatted
cargo test --workspace           # All tests must pass
cargo doc --no-deps              # Documentation must build
```

**Next Steps:**
1. Create workspace Cargo.toml with configuration above
2. Initialize crush-core and crush-cli crates
3. Set up toolchain, formatting, and linting configs
4. Implement minimal lib.rs and main.rs stubs
5. Verify clean compilation with strict lints

---

## 8. Magic Number Format and File Header Structure for Plugin System

### Context

Crush's plugin architecture requires a robust file format identification system. Each compression plugin must define a unique magic number to route decompression to the correct plugin. The file header must provide enough metadata for decompression while minimizing overhead on small files.

### Research Findings

#### 8.1 Existing Format Survey

**GZIP (RFC 1952):**
- **Magic Number**: `0x1F 0x8B` (2 bytes)
- **Compression Method**: 1 byte (0x08 for DEFLATE)
- **Flags**: 1 byte (indicates optional sections)
- **Timestamp**: 4 bytes (little-endian Unix timestamp)
- **Extra Flags**: 1 byte
- **OS Identifier**: 1 byte
- **Total Header**: 10 bytes minimum, variable with optional sections (filename, comment, CRC16)
- **Endianness**: Little-endian for multi-byte values

**Zstandard (RFC 8878):**
- **Magic Number**: `0x28 0xB5 0x2F 0xFD` (4 bytes)
- **Frame Header**: Variable size based on descriptor flags
- **Frame Descriptor**: 1-2 bytes encoding window size, content size flag, checksum flag
- **Content Size**: 0, 1, 2, or 8 bytes (optional)
- **Dictionary ID**: 0 or 4 bytes (optional)
- **Total Header**: Minimum 4 bytes magic + 1 byte descriptor = 5 bytes, maximum ~20 bytes
- **Endianness**: Little-endian (0xFD2FB528 when read as 32-bit LE integer)
- **Skippable Frames**: Magic 0x184D2A5X (where X = 0-F) allows embedding metadata

**bzip2:**
- **Magic Number**: `0x42 0x5A 0x68` (3 bytes, ASCII "BZh")
- **Block Size**: 1 byte (indicates 100k-900k block size)
- **Stream Composition**: Multiple blocks with block magic `0x314159265359` (6 bytes, digits of π)
- **Total Header**: 4 bytes minimum (magic + block size)
- **Design Note**: Uses mathematical constants for magic numbers (π digits)

**LZ4 Frame Format:**
- **Magic Number**: `0x04 0x22 0x4D 0x18` (4 bytes, little-endian: 0x184D2204)
- **Frame Descriptor**: 3-15 bytes (flags, block size, content size, dictionary ID)
- **Total Header**: 7-19 bytes
- **Skippable Frames**: Magic `0x184D2A50` through `0x184D2A5F` (16 variants)
- **Endianness**: Little-endian
- **Design Note**: Reserved magic number range for future extensions

**Brotli:**
- **Magic Number**: **NONE**
- **Critical Gap**: No file-level magic bytes, only stream-level metadata
- **Impact**: Difficult to identify `.br` files without trying decompression
- **Lesson**: Lack of magic numbers creates usability and tooling problems

#### 8.2 Magic Number Size Analysis

| Size | Formats | Collision Risk | Recommendations |
|------|---------|----------------|-----------------|
| **2 bytes** | GZIP, JPEG | Higher (65,536 combinations) | Acceptable for single-purpose formats |
| **4 bytes** | Zstd, LZ4, ZIP | Low (4.3 billion combinations) | **Industry standard** for modern formats |
| **8 bytes** | PNG | Minimal (2^64 combinations) | Overkill for most use cases |

**Key Findings:**
- **4 bytes is the modern standard**: Balances collision resistance with overhead
- **Little-endian preferred**: Matches x86/ARM architectures, simplifies implementation
- **Reserved ranges**: LZ4's approach of reserving 0x184D2A5X for skippable frames enables extensibility

#### 8.3 Header Overhead Impact on Small Files

From compression benchmarks and format analysis:

**LZAV (Low-Overhead Algorithm):**
- Hash-table-based compression has minimal memory overhead
- Ideal for small data (< 1KB)
- Header size critical for compression ratio on small files

**Analysis:**
- **10-byte header** (like GZIP): 10% overhead on 100-byte file
- **20-byte header**: 20% overhead on 100-byte file, 2% on 1KB file
- **Acceptable threshold**: < 5% overhead on 1KB files = max 50 bytes
- **Optimal range**: 12-24 bytes for most use cases

**Zstandard Strategy:**
- Minimum 5 bytes (magic + descriptor) for simple frames
- Optional fields increase size only when needed
- Excellent overhead/feature tradeoff

#### 8.4 Collision Prevention Strategies

**No Centralized Registry:**
- IANA maintains protocol parameter registries (port numbers, MIME types)
- **File format magic numbers are NOT centralized** (unlike port numbers)
- Community-maintained lists exist (Gary Kessler's table, Wikipedia) but are informational only

**Prevention Strategies:**

1. **Reserved Ranges (Recommended):**
   - Reserve `0xCR` prefix for Crush formats (CR = "CRush")
   - Default plugins: `0xCR 0x00` - `0xCR 0x0F` (16 reserved IDs)
   - User plugins: `0xCR 0x10` - `0xCR 0xFF` (240 available IDs)
   - Future expansion: `0xCR 0xXX 0xYY` (2-byte plugin IDs)

2. **Runtime Registry Validation:**
   - Plugin manager maintains HashMap of registered magic numbers
   - Registration fails if magic number already exists
   - First-come-first-served within application instance

3. **Global Uniqueness Check:**
   - Compare against known formats database (embedded or external)
   - Warn developers if chosen magic conflicts with popular formats
   - Non-blocking warning (allows override for internal use)

4. **UUID Alternative (Not Recommended):**
   - 16-byte UUID guarantees uniqueness
   - **Rejected**: 16 bytes is excessive overhead (16% on 100-byte file)
   - Better suited for file metadata, not magic numbers

#### 8.5 Header Structure Best Practices

**Extensibility Lessons from ZIP:**
- ZIP's "Extra" data fields enable format evolution
- Supports ZIP64, AES encryption, timestamps without breaking compatibility
- **Key Principle**: Reserve flags for future features from day one

**Versioning:**
- Include version field early (even if only one version exists)
- Enables format migration and deprecation paths
- Example: 1 byte = 256 format versions (sufficient for decades)

**Endianness:**
- **Little-endian (recommended)**: Matches x86, ARM, RISC-V (dominant architectures)
- Simplifies implementation on 95%+ of target platforms
- Big-endian only needed for network protocols or cross-platform binary formats

### Decision Recommendation

#### Magic Number Format

**Structure: 4-byte magic number with reserved range system**

```rust
/// Magic number structure for Crush compressed files
pub struct MagicNumber([u8; 4]);

impl MagicNumber {
    /// Crush magic number prefix (ASCII "CR" + version)
    pub const PREFIX: [u8; 2] = [0x43, 0x52]; // "CR"

    /// Format version (0x01 for V1)
    pub const VERSION: u8 = 0x01;

    /// Default DEFLATE plugin
    pub const DEFLATE: Self = Self([0x43, 0x52, 0x01, 0x00]);

    /// Reserved range for default plugins (0x00-0x0F)
    pub const RESERVED_START: u8 = 0x00;
    pub const RESERVED_END: u8 = 0x0F;

    /// User plugin range (0x10-0xFF)
    pub const USER_START: u8 = 0x10;
    pub const USER_END: u8 = 0xFF;

    /// Create magic number for a plugin
    pub const fn new(plugin_id: u8) -> Self {
        Self([Self::PREFIX[0], Self::PREFIX[1], Self::VERSION, plugin_id])
    }

    /// Validate magic number format
    pub fn validate(&self) -> Result<u8, FormatError> {
        if self.0[0..2] != Self::PREFIX {
            return Err(FormatError::InvalidMagic);
        }
        if self.0[2] != Self::VERSION {
            return Err(FormatError::UnsupportedVersion(self.0[2]));
        }
        Ok(self.0[3]) // Return plugin ID
    }
}
```

**Rationale:**
- **4 bytes total**: Industry standard, balances collision resistance and overhead
- **"CR" prefix (0x43 0x52)**: ASCII readable in hex dumps, unlikely to conflict
- **Version byte**: Enables format evolution (currently 0x01)
- **Plugin ID byte**: 256 possible plugins (16 reserved, 240 user-defined)
- **Little-endian**: Read as `0x00015243` on LE systems (natural byte order)

#### File Header Structure

**Structure: 16-byte fixed header + optional metadata**

```rust
/// Crush file header (16 bytes fixed size)
#[repr(C, packed)]
pub struct CrushHeader {
    /// Magic number (4 bytes: "CR" + version + plugin_id)
    pub magic: MagicNumber,

    /// Header flags (1 byte)
    /// Bit 0: Has original size field
    /// Bit 1: Has CRC32 checksum
    /// Bit 2: Has metadata section
    /// Bit 3: Reserved (compression level hint)
    /// Bit 4-7: Reserved for future use
    pub flags: u8,

    /// Original (uncompressed) size in bytes (8 bytes, little-endian)
    /// If size > u64::MAX, set to u64::MAX and use metadata section
    pub original_size: u64,

    /// CRC32 checksum of compressed data (4 bytes, little-endian)
    /// Computed from compressed payload only (excludes header)
    pub crc32: u32,

    // Total: 16 bytes (4 + 1 + 8 + 4 - 1 padding)
}

impl CrushHeader {
    pub const SIZE: usize = 16;

    /// Header flags
    pub const FLAG_HAS_SIZE: u8 = 0x01;
    pub const FLAG_HAS_CRC: u8 = 0x02;
    pub const FLAG_HAS_METADATA: u8 = 0x04;

    /// Create minimal header (magic + flags only)
    pub fn minimal(plugin_id: u8) -> Self {
        Self {
            magic: MagicNumber::new(plugin_id),
            flags: 0,
            original_size: 0,
            crc32: 0,
        }
    }

    /// Create header with size and CRC
    pub fn with_size_and_crc(plugin_id: u8, size: u64, crc: u32) -> Self {
        Self {
            magic: MagicNumber::new(plugin_id),
            flags: Self::FLAG_HAS_SIZE | Self::FLAG_HAS_CRC,
            original_size: size,
            crc32: crc,
        }
    }

    /// Serialize to bytes (little-endian)
    pub fn to_bytes(&self) -> [u8; Self::SIZE] {
        let mut bytes = [0u8; Self::SIZE];
        bytes[0..4].copy_from_slice(&self.magic.0);
        bytes[4] = self.flags;
        bytes[5..13].copy_from_slice(&self.original_size.to_le_bytes());
        bytes[13..17].copy_from_slice(&self.crc32.to_le_bytes());
        // Note: Adjust if padding differs
        bytes
    }

    /// Deserialize from bytes
    pub fn from_bytes(bytes: &[u8]) -> Result<Self, FormatError> {
        if bytes.len() < Self::SIZE {
            return Err(FormatError::TruncatedHeader);
        }

        let magic = MagicNumber([bytes[0], bytes[1], bytes[2], bytes[3]]);
        magic.validate()?;

        Ok(Self {
            magic,
            flags: bytes[4],
            original_size: u64::from_le_bytes(bytes[5..13].try_into().unwrap()),
            crc32: u32::from_le_bytes(bytes[13..17].try_into().unwrap()),
        })
    }
}
```

**Rationale:**

1. **16 bytes fixed size**:
   - Overhead: 1.6% on 1KB file, 0.16% on 10KB file (acceptable)
   - Cache-line friendly (fits in single 64-byte cache line with data)
   - Simpler parsing than variable-length headers

2. **Magic number (4 bytes)**:
   - Plugin identification and version checking

3. **Flags byte**:
   - Enables optional fields without breaking format
   - Extensible to 8 feature flags

4. **Original size (8 bytes)**:
   - Pre-allocates decompression buffer (performance optimization)
   - Enables progress reporting for large files
   - u64 supports files up to 16 exabytes

5. **CRC32 (4 bytes)**:
   - Detects corruption in compressed data
   - Fast to compute (crc32fast crate: ~16 GB/s)
   - Standard in ZIP, GZIP, PNG

6. **Little-endian**:
   - Matches x86/ARM architectures
   - Direct memory mapping on most platforms

7. **No padding fields**:
   - Packed representation saves space
   - Alignment handled by serialization code

**Optional Metadata Section (Future Extension):**

For plugins needing additional metadata (dictionary IDs, algorithm parameters):

```rust
/// Optional metadata section (follows header if FLAG_HAS_METADATA is set)
pub struct CrushMetadata {
    /// Metadata length (2 bytes, little-endian)
    pub length: u16,

    /// Plugin-specific metadata (variable length, max 65535 bytes)
    pub data: Vec<u8>,
}
```

#### Collision Handling Strategy

**Implementation:**

```rust
use std::collections::HashMap;

pub struct PluginRegistry {
    /// Maps magic numbers to plugin implementations
    plugins: HashMap<[u8; 4], Box<dyn CompressionPlugin>>,
}

impl PluginRegistry {
    /// Register a new plugin
    pub fn register(&mut self, plugin: Box<dyn CompressionPlugin>) -> Result<(), RegistryError> {
        let magic = plugin.magic_number();

        // Check for collisions in registry
        if self.plugins.contains_key(&magic.0) {
            return Err(RegistryError::MagicNumberCollision(magic.0));
        }

        // Optional: Check against known formats database
        if is_known_format(&magic.0) {
            eprintln!(
                "Warning: Magic number {:02X?} conflicts with known format. \
                 Use for internal purposes only.",
                magic.0
            );
        }

        self.plugins.insert(magic.0, plugin);
        Ok(())
    }

    /// Route decompression to correct plugin
    pub fn decompress(&self, data: &[u8]) -> Result<Vec<u8>, DecompressionError> {
        if data.len() < CrushHeader::SIZE {
            return Err(DecompressionError::TruncatedFile);
        }

        let header = CrushHeader::from_bytes(data)?;
        let magic = header.magic.0;

        let plugin = self.plugins.get(&magic)
            .ok_or(DecompressionError::UnknownFormat(magic))?;

        plugin.decompress(&data[CrushHeader::SIZE..])
    }
}

/// Database of well-known magic numbers to avoid collisions
fn is_known_format(magic: &[u8; 4]) -> bool {
    const KNOWN_FORMATS: &[[u8; 4]] = &[
        [0x1F, 0x8B, 0x08, 0x00], // GZIP
        [0x28, 0xB5, 0x2F, 0xFD], // Zstandard
        [0x04, 0x22, 0x4D, 0x18], // LZ4
        [0x50, 0x4B, 0x03, 0x04], // ZIP
        [0x52, 0x61, 0x72, 0x21], // RAR
        // Add more as needed
    ];

    KNOWN_FORMATS.contains(magic)
}
```

**Collision Prevention Features:**

1. **Runtime validation**: Registry refuses duplicate magic numbers
2. **Known format check**: Warns if conflicts with popular formats
3. **Reserved ranges**: Default plugins use 0x00-0x0F, user plugins use 0x10-0xFF
4. **Clear error messages**: Helps plugin developers fix collisions quickly

### Alternatives Considered

**1. UUID-Based Magic Numbers (16 bytes)**
- **Pros**: Guaranteed globally unique
- **Cons**: 16 bytes overhead (16% on 100-byte files), not human-readable
- **Verdict**: Rejected - overhead too high for magic numbers

**2. String Identifiers (e.g., "CRUSH-DEFLATE")**
- **Pros**: Human-readable, self-documenting
- **Cons**: Variable length, inefficient parsing, large overhead
- **Verdict**: Rejected - use for metadata, not magic numbers

**3. 2-Byte Magic Numbers (like GZIP)**
- **Pros**: Minimal overhead (2%)
- **Cons**: Only 65,536 combinations, higher collision risk
- **Verdict**: Rejected - insufficient for plugin system with many formats

**4. Variable-Length Headers (like ZIP)**
- **Pros**: Flexible, supports arbitrary metadata
- **Cons**: Complex parsing, non-deterministic overhead
- **Verdict**: Rejected for V1 - fixed header simpler, add metadata section later if needed

**5. Big-Endian Byte Order**
- **Pros**: Network byte order standard
- **Cons**: Requires byte-swapping on x86/ARM
- **Verdict**: Rejected - little-endian matches 95%+ of target platforms

### Header Size Comparison

| Format | Magic | Fixed Header | Optional Fields | Total Min | Total Max |
|--------|-------|--------------|-----------------|-----------|-----------|
| **GZIP** | 2 | 10 | Filename, comment, extra | 10 | ~1KB |
| **Zstandard** | 4 | 5 | Content size, dict ID | 5 | ~20 |
| **LZ4** | 4 | 7 | Content size, dict ID | 7 | 19 |
| **Bzip2** | 3 | 4 | None | 4 | 4 |
| **Crush (Proposed)** | 4 | 16 | Metadata section | 16 | ~64KB |

**Overhead Analysis:**
- **100-byte file**: 16% overhead (acceptable for small files not primary use case)
- **1KB file**: 1.6% overhead (excellent)
- **10KB file**: 0.16% overhead (negligible)
- **1MB file**: 0.0016% overhead (unmeasurable)

**Conclusion**: 16-byte header strikes optimal balance between features and overhead.

### Implementation Checklist

- [ ] Define `MagicNumber` struct with validation logic
- [ ] Implement `CrushHeader` with serialization/deserialization
- [ ] Create `PluginRegistry` with collision detection
- [ ] Add known format database for conflict warnings
- [ ] Write unit tests for header parsing (valid/invalid cases)
- [ ] Benchmark header overhead on file sizes: 100B, 1KB, 10KB, 1MB
- [ ] Document magic number allocation process for plugin developers
- [ ] Reserve default plugin IDs (0x00-0x0F) in registry

### References

- [RFC 1952: GZIP file format specification version 4.3](https://www.rfc-editor.org/rfc/rfc1952)
- [RFC 8878: Zstandard Compression and the 'application/zstd' Media Type](https://datatracker.ietf.org/doc/html/rfc8878)
- [LZ4 Frame Format Description](https://github.com/lz4/lz4/blob/release/doc/lz4_Frame_format.md)
- [List of file signatures - Wikipedia](https://en.wikipedia.org/wiki/List_of_file_signatures)
- [Unix Magic Numbers - The Hitchhiker's Guide to Compression](https://go-compression.github.io/reference/magic_numbers/)
- [Zstandard Compression Format Documentation](https://fuchsia.googlesource.com/third_party/zstd/+/refs/tags/v0.7.2/zstd_compression_format.md)
- [bzip2 - Wikipedia](https://en.wikipedia.org/wiki/Bzip2)
- [Standardize some magic bytes to identify a brotli stream · Issue #298](https://github.com/google/brotli/issues/298)
- [File Magic Numbers - GitHub Gist](https://gist.github.com/leommoore/f9e57ba2aa4bf197ebc5)
- [Gary Kessler's File Signatures Table](https://www.garykessler.net/library/file_sigs.html)

name: Release

on:
  push:
    branches:
      - 'release/**'
  workflow_dispatch:
    inputs:
      version:
        description: 'Version to release (e.g., 0.1.0)'
        required: true
        type: string

concurrency:
  group: release-${{ github.ref }}
  cancel-in-progress: false  # Never cancel release workflows

permissions:
  id-token: write
  contents: write
  pull-requests: read

env:
  CARGO_TERM_COLOR: always

jobs:
  validate_version:
    name: Validate Version
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.get_version.outputs.version }}
    steps:
      - uses: actions/checkout@v4

      - name: Get version from Cargo.toml or input
        id: get_version
        run: |
          if [ -n "${{ github.event.inputs.version }}" ]; then
            VERSION="${{ github.event.inputs.version }}"
          else
            # Read from crush-core (workspace root has no [package] version)
            VERSION=$(grep -m1 '^version' crush-core/Cargo.toml | sed 's/.*"\(.*\)".*/\1/')
          fi
          echo "version=${VERSION}" >> $GITHUB_OUTPUT
          echo "Detected version: ${VERSION}"

      - name: Validate semver format
        run: |
          VERSION="${{ steps.get_version.outputs.version }}"
          if ! echo "$VERSION" | grep -Eq '^[0-9]+\.[0-9]+\.[0-9]+(-[a-zA-Z0-9.]+)?(\+[a-zA-Z0-9.]+)?$'; then
            echo "Error: Version '$VERSION' is not valid semver"
            exit 1
          fi
          echo "Version '$VERSION' is valid semver"

      - name: Check version uniqueness on crates.io
        run: |
          VERSION="${{ steps.get_version.outputs.version }}"

          # Check both workspace crates (workspace root has no [package] name)
          for CRATE_NAME in crush-core crush-cli; do
            echo "Checking ${CRATE_NAME}..."

            # Query crates.io API for existing versions
            HTTP_STATUS=$(curl -s -o /tmp/crates_response.json -w "%{http_code}" \
              "https://crates.io/api/v1/crates/${CRATE_NAME}/versions")

            if [ "$HTTP_STATUS" = "404" ]; then
              echo "Crate '${CRATE_NAME}' not found on crates.io (first publish)"
              continue
            fi

            if [ "$HTTP_STATUS" != "200" ]; then
              echo "Warning: Could not verify version uniqueness for '${CRATE_NAME}' (HTTP ${HTTP_STATUS})"
              continue
            fi

            # Check if version already exists
            if jq -e ".versions[] | select(.num == \"$VERSION\")" /tmp/crates_response.json > /dev/null 2>&1; then
              echo "Error: Version '${VERSION}' of '${CRATE_NAME}' already exists on crates.io"
              exit 1
            fi

            echo "Version '${VERSION}' of '${CRATE_NAME}' is unique on crates.io"
          done

  run_ci:
    name: Run CI Checks
    needs: [validate_version]
    uses: ./.github/workflows/ci.yml
    permissions:
      contents: read
      checks: write
      pull-requests: write

  build_musl_static:
    name: Build Static Linux Binary
    needs: [validate_version, run_ci]
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - uses: dtolnay/rust-toolchain@stable

      - name: Install cross
        uses: taiki-e/install-action@cross

      - name: Build musl binary
        run: cross build --release --target x86_64-unknown-linux-musl

      - name: Verify static binary
        run: |
          echo "=== File info ==="
          file target/x86_64-unknown-linux-musl/release/crush

          echo "=== Checking for dynamic dependencies ==="
          if ldd target/x86_64-unknown-linux-musl/release/crush 2>&1 | grep -qE "not a dynamic executable|statically linked"; then
            echo "✓ Binary is statically linked"
          else
            echo "✗ Binary has dynamic dependencies:"
            ldd target/x86_64-unknown-linux-musl/release/crush || true
            exit 1
          fi

      - name: Test in Alpine container
        run: |
          docker run --rm \
            -v $(pwd)/target/x86_64-unknown-linux-musl/release:/app \
            alpine:latest \
            /app/crush --version

      - name: Package binary
        run: |
          VERSION="${{ needs.validate_version.outputs.version }}"
          mkdir -p dist
          cp target/x86_64-unknown-linux-musl/release/crush dist/
          cd dist
          tar -czvf crush-${VERSION}-x86_64-unknown-linux-musl.tar.gz crush
          sha256sum crush-${VERSION}-x86_64-unknown-linux-musl.tar.gz > crush-${VERSION}-x86_64-unknown-linux-musl.tar.gz.sha256

      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: crush-${{ needs.validate_version.outputs.version }}-x86_64-unknown-linux-musl
          path: |
            dist/crush-*.tar.gz
            dist/crush-*.sha256
          retention-days: 7

  publish:
    name: Publish to crates.io
    needs: [validate_version, run_ci, build_musl_static]
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - uses: dtolnay/rust-toolchain@stable

      - name: Dry-run publish
        run: |
          # Workspace root has no [package] - must publish each crate individually
          # Core must be published first (cli depends on it)
          cargo publish --dry-run -p crush-core
          cargo publish --dry-run -p crush-cli

      - name: Authenticate with crates.io (OIDC)
        uses: rust-lang/crates-io-auth-action@v1
        id: cargo_auth

      - name: Publish crush-core to crates.io
        run: cargo publish --token ${{ steps.cargo_auth.outputs.token }} -p crush-core
        env:
          CARGO_REGISTRY_TOKEN: ${{ steps.cargo_auth.outputs.token }}

      - name: Wait for crates.io index update
        run: sleep 30

      - name: Publish crush-cli to crates.io
        run: cargo publish --token ${{ steps.cargo_auth.outputs.token }} -p crush-cli
        env:
          CARGO_REGISTRY_TOKEN: ${{ steps.cargo_auth.outputs.token }}

      - name: Retry publish on failure
        if: failure()
        run: |
          echo "Retrying publish after 30 seconds..."
          sleep 30
          cargo publish --token ${{ steps.cargo_auth.outputs.token }} -p crush-core || true
          sleep 10
          cargo publish --token ${{ steps.cargo_auth.outputs.token }} -p crush-cli
        env:
          CARGO_REGISTRY_TOKEN: ${{ steps.cargo_auth.outputs.token }}

  create_github_release:
    name: Create GitHub Release
    needs: [validate_version, publish, build_musl_static]
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Download musl artifact
        uses: actions/download-artifact@v4
        with:
          name: crush-${{ needs.validate_version.outputs.version }}-x86_64-unknown-linux-musl
          path: dist/

      - name: Create GitHub Release
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          VERSION="${{ needs.validate_version.outputs.version }}"

          gh release create "v${VERSION}" \
            --title "v${VERSION}" \
            --generate-notes \
            dist/crush-${VERSION}-x86_64-unknown-linux-musl.tar.gz \
            dist/crush-${VERSION}-x86_64-unknown-linux-musl.tar.gz.sha256

  merge_to_develop:
    name: Merge to develop
    needs: [validate_version, create_github_release]
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Configure Git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Merge to develop
        run: |
          VERSION="${{ needs.validate_version.outputs.version }}"
          RELEASE_BRANCH="${GITHUB_REF#refs/heads/}"

          git fetch origin develop
          git checkout develop
          git merge --no-ff "${RELEASE_BRANCH}" -m "Merge release v${VERSION} to develop"
          git push origin develop

  merge_to_main:
    name: Merge to main
    needs: [merge_to_develop, validate_version]
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Configure Git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Merge to main
        run: |
          VERSION="${{ needs.validate_version.outputs.version }}"
          RELEASE_BRANCH="${GITHUB_REF#refs/heads/}"

          git fetch origin main
          git checkout main
          git merge --no-ff "${RELEASE_BRANCH}" -m "Merge release v${VERSION} to main"
          git push origin main
